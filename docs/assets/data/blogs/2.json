{
  "_id": "599ecbe9f36d281bbd021061",
  "blogId": 2,
  "headline": "Understanding Token Authentication",
  "updatedDate": 1472686620266,
  "markdown": "When building single page apps, it is quite common to want to use bearer token authentication, however it can be a little tricky to get working. The following posts will be a guide on how to do it. This first part is about understanding how bearer tokens work.\n\nToken authentication is a way of authenticating users without requiring a session on the server. This makes it ideal for use in multi-server environments (e.g. behind a load balancer), and/or where the server is acting as a simple REST API (typical for single page apps). This is how it works:\n\n1. The client logs in using a username/password (or an auth provider such as Facebook or Google login)\n2. The server validates the login details and creates a token containing the user's claims/permissions, and an expiry date for the token\n3. This token is then encrypted with a private key known only to the server, before being sent to the client\n4. The client then sends this encrypted token in the header of all requests it makes, and the server can decrypt this token in the request header and see what permissions the user has\n \n\nNote that we don't want the server to have to check the database every time it recieves a token in a request, it is more efficient if the server can know the user's permissions just from the decrypted token. However, if an attacker manages to steal a user's token then there is nothing we can do to stop them, we just have to wait until that token expires. For this reason tokens will typically only be valid for a short time after they are created (e.g. 10 minutes).\n\nThis gives rise to a new problem in that once the token expires the client will have to request a new one, but we don't want the user to have to re-enter their username & password every few minutes. To fix this problem we will introduce a second type of token, called a **refresh token**, and for clarity let's refer to the token I have been talking about so far as an **access token**.\n\nWhen the user logs in, we will actually send the client a refresh token (in addition to the access token). The refresh token need not be encrypted, it must simply be impossible to guess (a random string of 20 characters will work well). This refresh token will be saved in the database alongside the user.\nAll that is needed then is to provide a second way for the user to get an access token, this time by checking that they have a refresh token which matches the database.\n"
}
