{
  "_id": "599ecbfbf36d281bbd021070",
  "blogId": 1,
  "headline": "Injecting stylesheets with angularJS",
  "updatedDate": 1465502586547,
  "markdown": "I had a play around with using angular to modify what stylesheets are loaded by the browser. The goal was to only have stylesheets loaded that were relevant for the current page (technically the current `route` in a single page app), and the motivation behind this was that in a single page app you normally would have to have all the stylesheets for the whole site loaded at once. This is a problem because it means you have to be careful with your css selectors, to make sure that rules don't get accidentally applied to other parts of the site they weren't intended for.\n\n## Creating the directive\n\nIt turns out that it is quite easy to get angular to manipulate the loaded stylesheets. We simply create a directive like this:\n\n*Note: I've used the ES6 [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) notation. I thoroughly recommend using [typescript](http://www.typescriptlang.org/) instead of plain javascript.*\n\n```typescript\nangular.module('app').directive('injectStyles', () => ({\n    replace: true,\n    restrict: 'E',\n    scope: {},\n    template: '<link ng-repeat=\"url in stylesheets\" ng-href=\"{{url}}\" rel=\"stylesheet\" />',\n    link: (scope) => {\n        scope.stylesheets = [];\n    }\n}));\n```\n\n\nThen we put it in the `head` section:\n\n*Note: for this to work you must have the ng-app directive on the `html` element.*\n\n```html\n<html ng-app=\"app\">\n    <head>\n        <!-- other stuff -->\n        <inject-styles></inject-styles>\n    </head>\n    <!-- body etc. -->\n</html>\n```\n\n## Updating the stylesheet list\n\nNow we just need to keep the `stylesheets` variable up-to-date with what we want loaded. If we are using [`angular-ui-router`](https://github.com/angular-ui/ui-router) to do the routing, then we need to add a `stylesheetUrl` property to each of the views in our state config:\n\n```typescript\n$stateProvider.state('home', {\n    url: '/home',\n    views: {\n        '': {\n            templateUrl: 'views/home/home.html',\n            stylesheetUrl: 'views/home/home.css',\n            controller: ...\n        }\n    }\n});\n```\n\nThen we can hook onto the `$stateChangeSuccess` event in our directive:\n\n*Note: if the `_` seems mysterious it's because I'm using [lodash](https://lodash.com/).*\n\n```typescript\nangular.module('app').directive('injectStyles', ['$rootScope', ($rootScope) => ({\n    replace: true,\n    restrict: 'E',\n    scope: {},\n    template: '<link ng-repeat=\"url in stylesheets\" ng-href=\"{{url}}\" rel=\"stylesheet\" />',\n    link: (scope) => {\n        scope.stylesheets = [];\n\n        $rootScope.$on('$stateChangeStart', (event, toState) => {\n            scope.stylesheets =  _(toState.views)\n                .pluck('stylesheetUrl')\n                .filter(value => value !== undefined)\n                .value();\n        });\n    }\n})]);\n```\n\nNow whenever the user changes state, the stylesheets in the `head` element will be replaced with the ones for the new state!\n\n## Nested states\n\nThis gives the general idea, but we need to make it more robust if we want to have nested states:\n\n*Note: you will need to inject the `$state` service here as well as `$rootScope` above.*\n\n```typescript\nlink: (scope) => {\n    scope.stylesheets = [];\n\n    $rootScope.$on('$stateChangeStart', (event, toState) => {\n        let ancestorNames = [];\n        let currentName = '';\n        _.forEach(nameFragments, fragment => {\n            currentName = currentName + (currentName ? '.' : '') + fragment;\n            ancestorNames.push(currentName);\n        });\n\n        scope.stylesheets = _($state.get())\n            .filter(state => _.includes(ancestorNames, state.name))\n            .flatMap(state => _.map(state.views, 'stylesheetUrl'))\n            .filter(value => value !== undefined)\n            .value();\n    });\n}\n```\n\n# Problems\n\n## Transitions\n\nThere might be an animation when changing state, where both views are displayed at once for a short period. In this situation we don't want to remove all the stylesheets of the old state whilst it is still displayed! It is easy enough to fix this by listening to the `$stateChangeSuccess` event, but I won't include it here for brevity.\n\n## Browser loading time\n\nThere is a significant problem in that when a stylesheet is added to the head section, the browser has to parse the css file. This means that there is a delay between when the head section is modified and when the style rules actually get applied. At least in Chrome at the time of testing, this parsing delay happens even if the css is cached by the browser, and I cannot find a way to solve the issue. If it is a problem for you then you will have to ditch this approach and go back to careful namespacing of the css I'm afraid!"
}
